(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{447:function(t,a,v){"use strict";v.r(a);var _=v(40),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"面向过程和面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向过程和面向对象"}},[t._v("#")]),t._v(" 面向过程和面向对象")]),t._v(" "),v("h3",{attrs:{id:"面向过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向过程"}},[t._v("#")]),t._v(" 面向过程")]),t._v(" "),v("p",[v("strong",[t._v("面向过程")]),t._v("：先分析好的具体步骤，然后按照步骤，一步步解决问题。")]),t._v(" "),v("p",[t._v("优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。")]),t._v(" "),v("p",[t._v("缺点：没有面向对象易维护、易复用、易扩展。")]),t._v(" "),v("h3",{attrs:{id:"面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),v("p",[v("strong",[t._v("面向对象")]),t._v("（OOP，Object Oriented Programming）：以对象功能来划分问题，而不是步骤。")]),t._v(" "),v("p",[t._v("优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。")]),t._v(" "),v("p",[t._v("缺点：性能比面向过程低。")]),t._v(" "),v("h3",{attrs:{id:"面向对象的编程思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的编程思想"}},[t._v("#")]),t._v(" 面向对象的编程思想")]),t._v(" "),v("p",[t._v("面向对象的编程思想：对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口。")]),t._v(" "),v("p",[t._v("比如说，当我们在开车的时候，无需关心汽车的内部构造有多复杂，对于大多数人而言，只需要会开、知道汽车有哪些功能就行了。")]),t._v(" "),v("h3",{attrs:{id:"面向对象的特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的特性"}},[t._v("#")]),t._v(" 面向对象的特性")]),t._v(" "),v("p",[t._v("在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律。")]),t._v(" "),v("p",[t._v("面向对象的特性如下：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("封装性")])]),t._v(" "),v("li",[v("p",[t._v("继承性")])]),t._v(" "),v("li",[v("p",[t._v("多态性")])])]),t._v(" "),v("h2",{attrs:{id:"js-中的面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js-中的面向对象"}},[t._v("#")]),t._v(" JS 中的面向对象")]),t._v(" "),v("p",[t._v("JS 中的面向对象，是基于"),v("strong",[t._v("原型")]),t._v("的面向对象。")]),t._v(" "),v("p",[t._v("另外，在ES6中，新引入了 类（Class）和继承（Extends）来实现面向对象。")]),t._v(" "),v("h3",{attrs:{id:"基于原型的面向对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基于原型的面向对象"}},[t._v("#")]),t._v(" 基于原型的面向对象")]),t._v(" "),v("p",[t._v("JS 中的对象（Object）是依靠构造器（constructor）和原型（prototype）构造出来的。")])])}),[],!1,null,null,null);a.default=s.exports}}]);