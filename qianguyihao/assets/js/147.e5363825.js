(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{516:function(e,t,s){"use strict";s.r(t);var v=s(40),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"node-js-的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js-的特点"}},[e._v("#")]),e._v(" Node.js 的特点")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("异步、非阻塞 IO 模型")])]),e._v(" "),s("li",[s("p",[e._v("事件循环")])]),e._v(" "),s("li",[s("p",[e._v("单线程")])]),e._v(" "),s("li",[s("p",[e._v("总结：轻量和高效")])])]),e._v(" "),s("p",[e._v("Node.js 的性能和效率非常高。")]),e._v(" "),s("p",[e._v("传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个线程。而 Node.js 则完全没有采用这种模型，它本质上就是一个单线程。")]),e._v(" "),s("p",[e._v("你可能会疑问：一个线程如何服务于大量的请求、如何处理高并发的呢？这是因为，Node.js 采用的是异步的、非阻塞的模型。")]),e._v(" "),s("p",[e._v("这里所谓的“单线程”，指的是 Node 的主线程只有一个。为了确保主线程不被阻塞，主线程是用于接收客户端请求。但不会处理具体的任务。而 Node 的背后还有一个线程池，线程池会处理长时间运行的任务（比如 IO 操作、网络操作）。线程池里的任务是通过队列和事件循环的机制来执行。")]),e._v(" "),s("h2",{attrs:{id:"使用-node-js-时的劣势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-node-js-时的劣势"}},[e._v("#")]),e._v(" 使用 Node.js 时的劣势")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("程序运行不稳定，可能会出现服务不可用的情况")])]),e._v(" "),s("li",[s("p",[e._v("程序运行效率较低，每秒的请求数维持在一个较低的水平")])]),e._v(" "),s("li",[s("p",[e._v("前端同学对服务器端的技术不太熟悉。")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);