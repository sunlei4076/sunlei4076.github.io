(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{552:function(t,e,v){"use strict";v.r(e);var _=v(40),n=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"组件的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件的生命周期"}},[t._v("#")]),t._v(" 组件的生命周期")]),t._v(" "),v("p",[t._v("在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生命周期。")]),t._v(" "),v("h2",{attrs:{id:"生命周期的阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期的阶段"}},[t._v("#")]),t._v(" 生命周期的阶段")]),t._v(" "),v("p",[t._v("组件生命周期分为三个阶段，下面分别来讲解。")]),t._v(" "),v("h3",{attrs:{id:"_1、组件创建阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、组件创建阶段"}},[t._v("#")]),t._v(" 1、组件创建阶段")]),t._v(" "),v("blockquote",[v("p",[t._v("组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次。")])]),t._v(" "),v("ul",[v("li",[t._v("getDefaultProps")])]),t._v(" "),v("p",[t._v("初始化 props 属性默认值。")]),t._v(" "),v("ul",[v("li",[t._v("getInitialState")])]),t._v(" "),v("p",[t._v("初始化组件的私有数据。因为 state 是定义在组件的 constructor 构造器当中的，只要new 了 class类，必然会调用 constructor构造器。")]),t._v(" "),v("ul",[v("li",[t._v("componentWillMount()")])]),t._v(" "),v("p",[t._v("组件将要被挂载。此时还没有开始渲染虚拟DOM。")]),t._v(" "),v("p",[t._v("在这个阶段，不能去操作DOM元素，但可以操作属性、状态、function。相当于 Vue 中的Create()函数。")]),t._v(" "),v("ul",[v("li",[t._v("render()")])]),t._v(" "),v("p",[t._v("第一次开始渲染真正的虚拟DOM。当render执行完，内存中就有了完整的虚拟DOM了。")]),t._v(" "),v("p",[t._v("意思是，此时，虚拟DOM在内存中创建好了，但是还没有挂在到页面上。")]),t._v(" "),v("p",[t._v("在这个函数内部，不能去操作DOM元素，"),v("strong",[t._v("因为还没return之前，虚拟DOM还没有创建")]),t._v("；当return执行完毕后，虚拟DOM就创建好了，但是还没有挂在到页面上。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("componentDidMount()")])])]),t._v(" "),v("p",[v("strong",[t._v("当组件（虚拟DOM）挂载到页面之后，会进入这个生命周期函数")]),t._v("。")]),t._v(" "),v("p",[t._v("只要进入到这个生命周期函数，则必然说明，页面上已经有可见的DOM元素了。此时，组件已经显示到了页面上，state上的数据、内存中的虚拟DOM、以及浏览器中的页面，已经完全保持一致了。")]),t._v(" "),v("p",[t._v("当这个方法执行完，组件就进入都了 运行中 的状态。所以说，componentDidMount 是创建阶段的最后一个函数。")]),t._v(" "),v("p",[t._v("在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。如果我们想操作DOM元素，最早只能在 componentDidMount 中进行。相当于 Vue 中的 mounted() 函数")]),t._v(" "),v("h3",{attrs:{id:"_2、组件运行阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、组件运行阶段"}},[t._v("#")]),t._v(" 2、组件运行阶段")]),t._v(" "),v("blockquote",[v("p",[t._v("有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次。")])]),t._v(" "),v("ul",[v("li",[t._v("componentWillReceiveProps()")])]),t._v(" "),v("p",[t._v("组件将要接收新属性。只有当父组件中，通过某些事件，重新修改了 传递给 子组件的 props 数据之后，才会触发这个钩子函数。")]),t._v(" "),v("ul",[v("li",[t._v("shouldComponentUpdate()")])]),t._v(" "),v("p",[t._v("判断组件是否需要被更新。此时，组件尚未被更新，但是，state 和 props 肯定是最新的。")]),t._v(" "),v("ul",[v("li",[t._v("componentWillUpdate()")])]),t._v(" "),v("p",[t._v("组件将要被更新。此时，组件还没有被更新，在进入到这个生命周期函数的时候，内存中的虚拟DOM还是旧的，页面上的 DOM 元素也是旧的。（也就是说，此时操作的是旧的 DOM元素）")]),t._v(" "),v("ul",[v("li",[t._v("render")])]),t._v(" "),v("p",[t._v("此时，又要根据最新的 state 和 props，重新渲染一棵内存中的 虚拟DOM树。当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时，虚拟DOM树已经和组件的 state 保持一致了，都是最新的；但是页面还是旧的。")]),t._v(" "),v("ul",[v("li",[t._v("componentDidUpdate")])]),t._v(" "),v("p",[t._v("此时，组件完成更新，页面被重新渲染。此时，state、虚拟DOM 和 页面已经完全保持同步。")]),t._v(" "),v("h3",{attrs:{id:"_3、组件销毁阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、组件销毁阶段"}},[t._v("#")]),t._v(" 3、组件销毁阶段")]),t._v(" "),v("p",[t._v("一辈子只执行一次。")]),t._v(" "),v("ul",[v("li",[t._v("componentWillUnmount: 组件将要被卸载。此时组件还可以正常使用。")])]),t._v(" "),v("p",[t._v("React 生命周期的截图如下：")]),t._v(" "),v("p",[t._v("20190212_1745.jpg")]),t._v(" "),v("p",[t._v("生命周期对比：")]),t._v(" "),v("ul",[v("li",[v("p",[v("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue中的生命周期图"),v("OutboundLink")],1)])]),t._v(" "),v("li",[v("p",[v("a",{attrs:{href:"http://www.race604.com/react-native-component-lifecycle/",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Native 中组件的生命周期"),v("OutboundLink")],1)])])]),t._v(" "),v("h2",{attrs:{id:"组件生命周期的执行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件生命周期的执行顺序"}},[t._v("#")]),t._v(" 组件生命周期的执行顺序")]),t._v(" "),v("p",[v("strong",[t._v("1、Mounting")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("constructor()")])]),t._v(" "),v("li",[v("p",[t._v("componentWillMount()")])]),t._v(" "),v("li",[v("p",[t._v("render()")])]),t._v(" "),v("li",[v("p",[t._v("componentDidMount()")])])]),t._v(" "),v("p",[v("strong",[t._v("2、Updating")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("componentWillReceiveProps(nextProps)：接收父组件传递过来的属性")])]),t._v(" "),v("li",[v("p",[t._v("shouldComponentUpdate(nextProps, nextState)：一旦调用 setState，就会触发这个方法。方法默认 return true；如果 return false，后续的方法就不会走了。")])]),t._v(" "),v("li",[v("p",[t._v("componentWillUpdate(nextProps, nextState)")])]),t._v(" "),v("li",[v("p",[t._v("render()")])]),t._v(" "),v("li",[v("p",[t._v("componentDidUpdate(prevProps, prevState)")])])]),t._v(" "),v("p",[v("strong",[t._v("3、Unmounting")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("componentWillUnmount()")])])])}),[],!1,null,null,null);e.default=n.exports}}]);